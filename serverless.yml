# The service name, a service is a collection of related functions
# This is a placeholder change it to the actual server name
service: mweb-serverless-api-starter

# Plugins used by serverless framework for this service
plugins:
  # Performs python library packaging in a docker image that reproduces the aws lambda environment
  # as some python packages are OS specific
  - serverless-python-requirements
  # handle API GW events by converting them to wsgi so that Flask can be used
  - serverless-wsgi

# Define what should be excluded when zipping up the lambda 
package:
  exclude:
    - node_modules/**
    - venv/**
    - docs/**
    - data/**
    - tests/**
    - package.json
    - package-lock.json
    - run_integration_tests.sh
    - run_unit_tests.sh

provider:
  # By default AWS keeps all versions of the function, this is not needed
  versionFunctions: false
  # Determines how long cloudwatch logs are kept, this defaults to forever
  logRetentionInDays: 30
  # Deployment will be to AWS
  name: aws
  # Python 3.8 will be used
  runtime: python3.8
  # Memory size is a dial that controls both RAM and CPU
  # Allocating more RAM will result in more CPU being allocated to the lambda
  memorySize: 512
  # The stage forms part of the lambda name - it can be any value but usually dev and prod are used
  stage: ${opt:stage, 'dev'}
  # The points to the AWS key id and secret that is stored in
  # ~/.aws/credentials
  # For example:
  # [mweb]
  # aws_access_key_id = AKIAJA4Q....
  # aws_secret_access_key = XEy5EAS0....
  # [renoir-sls]
  # aws_access_key_id = AKIAJASO....
  # aws_secret_access_key = ywj6m4ct.... 
  profile: ${opt:profile, 'mweb'}
  # The region in which the lambda should be deployed
  region: ${opt:region, 'eu-west-1'}
  
  # The serverless framework usually creates a new bucket
  # for each new service-stage combination. To prevent many
  # buckets being created one can specify a deployment bucket
  #
  # Reuse an existing bucket for the deployment artifacts
  deploymentBucket:
    name: mweb-serverless-deployments
  
  # Define tags
  tags:
    "mweb:billing": "${self:provider.stage}"
    "mweb:name": "${self:service}"

  # IAM roles to access resources defined later in the file
  iamRoleStatements:
    # Only DynamoDB is accessed from the lambda
    - Effect: Allow
      Action:
        - dynamodb:Query
        - dynamodb:Scan
        - dynamodb:GetItem
        - dynamodb:PutItem
        - dynamodb:UpdateItem
        - dynamodb:DeleteItem
      Resource:
        - { "Fn::GetAtt": ["ServiceTable", "Arn" ] }

  # Define environment variables
  environment:
    SERVICE_TABLE_NAME: ${self:custom.service_table_name}

  # Define API keys, values will be generated by AWS
  apiKeys:
    - ${self:service}-apikey-${self:provider.stage}

#
# Define Custom Variables
#
custom:
  # dynamodb
  service_table_name: ${self:service}-${self:provider.stage}

  # http via wsgi
  wsgi:
    app: api.app
    packRequirements: false
    pythonBin: python
  
  # python build
  pythonRequirements:
    fileName: requirements-prod.txt
    noDeploy: []
    dockerizePip: true

#
# Define the functions
#
functions:
  #
  # Function meant to handle unauthed user requests - no JWT or API key necessary
  #
  userapp:
    handler: wsgi_handler.handler
    timeout: 5
    events:
      # Get the callers ip address
      - http:
          path: starter/myip
          method: GET
          cors: true

  #
  # These functions will need an API key to be invoked, it should be included an an x-api-key header
  # The API key will be generated when the lambda is initially deployed
  #
  admin:
    handler: wsgi.handler
    timeout: 5
    events:
      # Get sample data
      - http:
          path: starter/sample_data
          method: GET
          cors: true
          private: true
      # Save sample data
      - http:
          path: starter/sample_data
          method: POST
          cors: true
          private: true

#
# Define AWS Resources
#
resources:
  Resources:
    # DynamoDB Table
    ServiceTable:
      Type: AWS::DynamoDB::Table
      Properties:
        AttributeDefinitions:
          -
            AttributeName: table_partition_key
            AttributeType: S
          -
            AttributeName: table_sort_key
            AttributeType: S
        KeySchema:
          -
            AttributeName: table_partition_key
            KeyType: HASH
          -
            AttributeName: table_sort_key
            KeyType: RANGE
        BillingMode: PAY_PER_REQUEST
        TimeToLiveSpecification:
          AttributeName: delete_timestamp_utc
          Enabled: true
        TableName: ${self:custom.service_table_name}

